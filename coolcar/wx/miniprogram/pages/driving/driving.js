"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const trip_1 = require("../../service/trip");
const routing_1 = require("../../utils/routing");
const updateIntervalSec = 5;
Page({
    tripID: '',
    timer: undefined,
    data: {
        location: {
            latitude: 32.92,
            longitude: 118.46,
        },
        scale: 14,
        elapsed: '00:00:00',
        fee: '0.00',
    },
    onLoad(opt) {
        const o = opt;
        this.tripID = o.trip_id;
        console.log('current trip', o.trip_id);
        trip_1.TripService.getTrip(o.trip_id).then(console.log);
        this.setupLocationUpdator();
        this.setupTimer(o.trip_id);
    },
    onUnload() {
        wx.stopLocationUpdate();
        if (this.timer) {
            clearInterval(this.timer);
        }
    },
    setupLocationUpdator() {
        wx.startLocationUpdate({
            fail: console.error,
        }),
            wx.onLocationChange(loc => {
                console.log('location: ', loc);
                this.setData({
                    location: {
                        latitude: loc.latitude,
                        longitude: loc.longitude,
                    },
                });
            });
    },
    setupTimer(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const trip = yield trip_1.TripService.updateTripPos(id);
            let secSinceLastUpdate = 0;
            let lastUpdateDurationSec = trip.current.timestampSec - trip.start.timestampSec;
            this.setData({
                elapsed: formatDuration(lastUpdateDurationSec),
                fee: formatFee(trip.current.feeCent)
            });
            this.timer = setInterval(() => {
                secSinceLastUpdate++;
                if (secSinceLastUpdate % 5 == 0) {
                    trip_1.TripService.updateTripPos(id, {
                        latitude: this.data.location.latitude,
                        longitude: this.data.location.longitude,
                    }).then(trip => {
                        lastUpdateDurationSec = trip.current.timestampSec - trip.start.timestampSec;
                        secSinceLastUpdate = 0;
                        this.setData({
                            fee: formatFee(trip.current.feeCent),
                        });
                    });
                }
                this.setData({
                    elapsed: formatDuration(lastUpdateDurationSec + secSinceLastUpdate),
                });
            }, 1000);
        });
    },
    onEndTripTap() {
        trip_1.TripService.finishTrip(this.tripID).then(() => {
            wx.redirectTo({
                url: routing_1.routing.mytrips()
            });
        }).catch(err => {
            console.error(err);
            wx.showToast({
                title: '行程结束',
                icon: 'none',
            });
        });
    }
});
function formatDuration(sec) {
    const padString = (n) => n < 10 ? '0' + n.toFixed(0) : n.toFixed(0);
    const h = Math.floor(sec / 3600);
    sec -= 3600 * h;
    const m = Math.floor(sec / 60);
    sec -= 60 * m;
    const s = Math.floor(sec);
    return `${padString(h)}:${padString(m)}:${padString(s)}`;
}
function formatFee(cents) {
    return (cents / 100).toFixed(2);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJpdmluZy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImRyaXZpbmcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQSw2Q0FBZ0Q7QUFDaEQsaURBQTZDO0FBRzdDLE1BQU0saUJBQWlCLEdBQUcsQ0FBQyxDQUFBO0FBRTNCLElBQUksQ0FBQztJQUNELE1BQU0sRUFBRSxFQUFFO0lBQ1YsS0FBSyxFQUFFLFNBQStCO0lBQ3RDLElBQUksRUFBRTtRQUNGLFFBQVEsRUFBRTtZQUNOLFFBQVEsRUFBRSxLQUFLO1lBQ2YsU0FBUyxFQUFFLE1BQU07U0FDcEI7UUFDRCxLQUFLLEVBQUUsRUFBRTtRQUNULE9BQU8sRUFBRSxVQUFVO1FBQ25CLEdBQUcsRUFBRSxNQUFNO0tBQ2Q7SUFFRCxNQUFNLENBQUMsR0FBOEI7UUFDakMsTUFBTSxDQUFDLEdBQXdCLEdBQUcsQ0FBQTtRQUNsQyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUE7UUFDdkIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFBO1FBRXRDLGtCQUFXLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFBO1FBQ2hELElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFBO1FBQzNCLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFBO0lBQzlCLENBQUM7SUFFRCxRQUFRO1FBQ0osRUFBRSxDQUFDLGtCQUFrQixFQUFFLENBQUE7UUFDdkIsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ1osYUFBYSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQTtTQUM1QjtJQUNMLENBQUM7SUFFRCxvQkFBb0I7UUFDaEIsRUFBRSxDQUFDLG1CQUFtQixDQUFDO1lBQ25CLElBQUksRUFBRSxPQUFPLENB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QyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUE7SUFFOUMsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLENBQUE7SUFDaEMsR0FBRyxJQUFJLElBQUksR0FBRyxDQUFDLENBQUE7SUFDZixNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsQ0FBQTtJQUM5QixHQUFHLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQTtJQUNiLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUE7SUFDekIsT0FBTyxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUE7QUFDNUQsQ0FBQztBQUVELFNBQVMsU0FBUyxDQUFDLEtBQWE7SUFDNUIsT0FBTyxDQUFDLEtBQUssR0FBRyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUE7QUFDbkMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRyaXBTZXJ2aWNlIH0gZnJvbSBcIi4uLy4uL3NlcnZpY2UvdHJpcFwiXHJcbmltcG9ydCB7IHJvdXRpbmcgfSBmcm9tIFwiLi4vLi4vdXRpbHMvcm91dGluZ1wiXHJcblxyXG4vLyBjb25zdCBjZW50UGVyU2VjID0gMC43XHJcbmNvbnN0IHVwZGF0ZUludGVydmFsU2VjID0gNSAvLyDmr48156eS5ZCR5pyN5Yqh5Zmo5LiK5oqlbG9jYXRpb25cclxuXHJcblBhZ2Uoe1xyXG4gICAgdHJpcElEOiAnJyxcclxuICAgIHRpbWVyOiB1bmRlZmluZWQgYXMgbnVtYmVyIHwgdW5kZWZpbmVkLFxyXG4gICAgZGF0YToge1xyXG4gICAgICAgIGxvY2F0aW9uOiB7XHJcbiAgICAgICAgICAgIGxhdGl0dWRlOiAzMi45MixcclxuICAgICAgICAgICAgbG9uZ2l0dWRlOiAxMTguNDYsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzY2FsZTogMTQsXHJcbiAgICAgICAgZWxhcHNlZDogJzAwOjAwOjAwJyxcclxuICAgICAgICBmZWU6ICcwLjAwJyxcclxuICAgIH0sXHJcblxyXG4gICAgb25Mb2FkKG9wdDogUmVjb3JkPCd0cmlwX2lkJywgc3RyaW5nPikge1xyXG4gICAgICAgIGNvbnN0IG86IHJvdXRpbmcuRHJpdmluZ09wdHMgPSBvcHRcclxuICAgICAgICB0aGlzLnRyaXBJRCA9IG8udHJpcF9pZFxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdjdXJyZW50IHRyaXAnLCBvLnRyaXBfaWQpXHJcbiAgICAgICAgLy8gby50cmlwX2lkID0gJzYyMmUxMGI5MTQ1OTJkNWM1MGNjYjdkYydcclxuICAgICAgICBUcmlwU2VydmljZS5nZXRUcmlwKG8udHJpcF9pZCkudGhlbihjb25zb2xlLmxvZylcclxuICAgICAgICB0aGlzLnNldHVwTG9jYXRpb25VcGRhdG9yKClcclxuICAgICAgICB0aGlzLnNldHVwVGltZXIoby50cmlwX2lkKVxyXG4gICAgfSxcclxuXHJcbiAgICBvblVubG9hZCgpIHtcclxuICAgICAgICB3eC5zdG9wTG9jYXRpb25VcGRhdGUoKVxyXG4gICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XHJcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcilcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHNldHVwTG9jYXRpb25VcGRhdG9yKCkge1xyXG4gICAgICAgIHd4LnN0YXJ0TG9jYXRpb25VcGRhdGUoe1xyXG4gICAgICAgICAgICBmYWlsOiBjb25zb2xlLmVycm9yLFxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgICAgICB3eC5vbkxvY2F0aW9uQ2hhbmdlKGxvYyA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnbG9jYXRpb246ICcsIGxvYylcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0RGF0YSh7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGF0aXR1ZGU6IGxvYy5sYXRpdHVkZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9uZ2l0dWRlOiBsb2MubG9uZ2l0dWRlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgfSxcclxuICAgIGFzeW5jIHNldHVwVGltZXIoaWQ6IHN0cmluZykge1xyXG4gICAgICAgIC8vIOWcqOi/m+WFpeaXtuWFiOeci+aVsOaNruW6k1xyXG4gICAgICAgIGNvbnN0IHRyaXAgPSBhd2FpdCBUcmlwU2VydmljZS51cGRhdGVUcmlwUG9zKGlkKVxyXG4gICAgICAgIGxldCBzZWNTaW5jZUxhc3RVcGRhdGUgPSAwICAgICAgLy8g6Led56a75LiK5qyh6K+35rGC5pyN5Yqh5Zmo6L+H5Y6755qE5pe26Ze0XHJcbiAgICAgICAgbGV0IGxhc3RVcGRhdGVEdXJhdGlvblNlYyA9IHRyaXAuY3VycmVudCEudGltZXN0YW1wU2VjISAtIHRyaXAuc3RhcnQhLnRpbWVzdGFtcFNlYyEgICAvLyDkuIrmrKHor6Lpl67mnI3liqHlmajml7Yg5pyN5Yqh5Zmo6L+U5Zue55qE6KGM6am25oC75pe26Ze0XHJcbiAgICAgICAgdGhpcy5zZXREYXRhKHtcclxuICAgICAgICAgICAgZWxhcHNlZDogZm9ybWF0RHVyYXRpb24obGFzdFVwZGF0ZUR1cmF0aW9uU2VjKSxcclxuICAgICAgICAgICAgZmVlOiBmb3JtYXRGZWUodHJpcC5jdXJyZW50IS5mZWVDZW50ISlcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICB0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xyXG4gICAgICAgICAgICBzZWNTaW5jZUxhc3RVcGRhdGUrK1xyXG4gICAgICAgICAgICBpZiAoc2VjU2luY2VMYXN0VXBkYXRlICUgNSA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBUcmlwU2VydmljZS51cGRhdGVUcmlwUG9zKGlkLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGF0aXR1ZGU6IHRoaXMuZGF0YS5sb2NhdGlvbi5sYXRpdHVkZSxcclxuICAgICAgICAgICAgICAgICAgICBsb25naXR1ZGU6IHRoaXMuZGF0YS5sb2NhdGlvbi5sb25naXR1ZGUsXHJcbiAgICAgICAgICAgICAgICB9KS50aGVuKHRyaXAgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RVcGRhdGVEdXJhdGlvblNlYyA9IHRyaXAuY3VycmVudCEudGltZXN0YW1wU2VjISAtIHRyaXAuc3RhcnQhLnRpbWVzdGFtcFNlYyFcclxuICAgICAgICAgICAgICAgICAgICBzZWNTaW5jZUxhc3RVcGRhdGUgPSAwXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXREYXRhKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmVlOiBmb3JtYXRGZWUodHJpcC5jdXJyZW50IS5mZWVDZW50ISksXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zZXREYXRhKHtcclxuICAgICAgICAgICAgICAgIGVsYXBzZWQ6IGZvcm1hdER1cmF0aW9uKGxhc3RVcGRhdGVEdXJhdGlvblNlYyArIHNlY1NpbmNlTGFzdFVwZGF0ZSksXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSwgMTAwMClcclxuICAgIH0sXHJcbiAgICBvbkVuZFRyaXBUYXAoKSB7XHJcbiAgICAgICAgVHJpcFNlcnZpY2UuZmluaXNoVHJpcCh0aGlzLnRyaXBJRCkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIHd4LnJlZGlyZWN0VG8oe1xyXG4gICAgICAgICAgICAgICAgdXJsOiByb3V0aW5nLm15dHJpcHMoKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKVxyXG4gICAgICAgICAgICB3eC5zaG93VG9hc3Qoe1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6ICfooYznqIvnu5PmnZ8nLFxyXG4gICAgICAgICAgICAgICAgaWNvbjogJ25vbmUnLFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcbn0pXHJcblxyXG5cclxuZnVuY3Rpb24gZm9ybWF0RHVyYXRpb24oc2VjOiBudW1iZXIpIHtcclxuICAgIGNvbnN0IHBhZFN0cmluZyA9IChuOiBudW1iZXIpID0+XHJcbiAgICAgICAgbiA8IDEwID8gJzAnICsgbi50b0ZpeGVkKDApIDogbi50b0ZpeGVkKDApXHJcblxyXG4gICAgY29uc3QgaCA9IE1hdGguZmxvb3Ioc2VjIC8gMzYwMClcclxuICAgIHNlYyAtPSAzNjAwICogaFxyXG4gICAgY29uc3QgbSA9IE1hdGguZmxvb3Ioc2VjIC8gNjApXHJcbiAgICBzZWMgLT0gNjAgKiBtXHJcbiAgICBjb25zdCBzID0gTWF0aC5mbG9vcihzZWMpXHJcbiAgICByZXR1cm4gYCR7cGFkU3RyaW5nKGgpfToke3BhZFN0cmluZyhtKX06JHtwYWRTdHJpbmcocyl9YFxyXG59XHJcblxyXG5mdW5jdGlvbiBmb3JtYXRGZWUoY2VudHM6IG51bWJlcikge1xyXG4gICAgcmV0dXJuIChjZW50cyAvIDEwMCkudG9GaXhlZCgyKVxyXG59Il19